diff --git a/src/htm_chord.c b/src/htm_chord.c
index dba37fe..8f9f0a9 100644
--- a/src/htm_chord.c
+++ b/src/htm_chord.c
@@ -21,6 +21,12 @@
 
 #include "htm.h"
 
+#if 0
+#define MIN_WEIGHT 0
+#define MID_WEIGHT 0x80
+#define MAX_WEIGHT 0xFF
+#endif
+
 const char *htm_chord_hex(chord_t *hash)
 {
 	static char ret_buf[4096];
@@ -33,22 +39,14 @@ const char *htm_chord_hex(chord_t *hash)
 	return ((const char *)ret_buf);
 }
 
-uint64_t htm_chord_inset(uint64_t seed, double x, double y, double z)
-{
-	int16_t inset[3];
-	
-	inset[0] = (int16_t)round(x);
-	inset[1] = (int16_t)round(y);
-	inset[2] = (int16_t)round(z);
-
-	return (crc64(seed, (int16_t *)inset, 6));
-}
-
+#if 0
 uint64_t htm_chord_csum(uint8_t *data, size_t data_len)
 {
 	return (crc64(0, data, data_len));
 }
+#endif
 
+#if 0
 double htm_chord_weight(chord_t *hash)
 {
 	double weight;
@@ -61,7 +59,9 @@ double htm_chord_weight(chord_t *hash)
 
 	return (weight);
 }
+#endif
 
+#if 0
 void htm_chord_weight_apply(chord_t *hash)
 {
 	htime diff;
@@ -69,7 +69,7 @@ void htm_chord_weight_apply(chord_t *hash)
 	int i;
 
 	now = htime_now();
-	diff = (now - hash->stamp)/2; /* 20ms */
+	diff = (now - hash->stamp) * 10; /* 1ms */
 
 	if (diff != 0) {
 		for (i = 0; i < CHORD_SIZE; i++) {
@@ -88,9 +88,15 @@ void htm_chord_weight_apply(chord_t *hash)
 
 void htm_chord_weight_incr(chord_t *hash, int idx)
 {
-	hash->weight[idx] = MIN(255, (int)hash->weight[idx] + 16);
+	hash->weight[idx] = MIN(255, (int)hash->weight[idx] + 32);
 }
 
+void htm_chord_weight_decr(chord_t *hash, int idx)
+{
+	hash->weight[idx] = MAX(0, (int)hash->weight[idx] - 32);
+}
+#endif
+
 #if 0
 void htm_chord_hash_init(chord_t *hash, chord_t *in_hash)
 {
@@ -264,6 +270,7 @@ void htm_chord_expand(chord_t *hash, uint64_t csum)
 
 }
 
+#if 0
 int htm_chord_spike(chord_t *hash)
 {
 	int idx;
@@ -271,6 +278,7 @@ int htm_chord_spike(chord_t *hash)
 	for (idx = 0; idx < CHORD_SIZE; idx++) {
 		if (hash->weight[idx] >= 0x80)
 			return (TRUE);
+fprintf(stderr, "DEBUG: htm_chord_spike: FALSE weight %d@idx %d\n", hash->weight[idx], idx);
 	}
 
 	return (FALSE);
@@ -285,6 +293,7 @@ void htm_chord_inhibit(chord_t *hash)
 	}
 
 }
+#endif
 
 #if 0
 /** Compact the hash into a number from 0 to 1.0 */
@@ -327,6 +336,7 @@ void htm_chord_digest(chord_t *hash, uint8_t *data, size_t data_len)
 }
 #endif
 
+#if 0
 int htm_chord_digest_bit(uint8_t ch)
 {
 	uint32_t ret_val;
@@ -336,65 +346,106 @@ int htm_chord_digest_bit(uint8_t ch)
 	nr = 0;
 	ret_val = 0;
 	for (k = 7; k >= 0; k--) {
-		if ((1 << k) & ch) {
+		if (ch & (1 << k)) {// & ch) {
 			ret_val |= (1 << k);
 			nr++;
-			if (nr >= 2)
+			if (nr >= 3)
 				break;
 		}
 	}
 
 	return (ret_val);
 }
+#endif
 
-void htm_chord_digest(chord_t *hash, uint32_t *seed_p, uint8_t *data, size_t data_len)
+static uint8_t select_bits(uint8_t val)
 {
-	char buf[CHORD_SIZE];
-	uint32_t weight[CHORD_SIZE];
+  uint8_t ret_val;
+  int tot;
+  int i;
+
+	tot = 0;
+	ret_val = 0;
+	if (val) {
+		for (i = 7; i >= 0; i--) {
+			if (val & (1 << i)) {
+				ret_val |= (1 << i);
+
+				tot++;
+				if (tot >= 3)
+					break;
+			}
+		}
+	}
+
+  return (ret_val);
+}
+
+uint8_t htm_chord_select(uint8_t val)
+{
+  uint8_t ret_val;
+  int tot;
+  int i;
+
+	tot = 0;
+	ret_val = 0;
+	if (val) {
+		for (i = 7; i >= 0; i--) {
+			if (val & (1 << i)) {
+				ret_val |= (1 << i);
+
+				tot++;
+				if (tot >= 3)
+					break;
+			}
+		}
+	}
+
+  return (ret_val);
+}
+
+int htm_chord_digest(chord_t *hash, uint32_t *seed_p, uint8_t *data, size_t data_len)
+{
+	unsigned char buf[CHORD_SIZE];
 	uint32_t col_idx;
-	uint32_t mid_weight;
+	uint32_t bit_seed;
+	uint32_t bit;
+	int is_bit;
 	int idx;
 	int of;
 
-	for (col_idx = 0; col_idx < CHORD_SIZE; col_idx++)
-		weight[col_idx] = 0;
-
+	is_bit = 0;
 	col_idx = 0;
+	bit_seed = 1;
 	for (of = 0; of < data_len; of += CHORD_SIZE) {
 		memset(buf, 0, sizeof(buf));
 		memcpy(buf, data + of, MIN(CHORD_SIZE, data_len - of));
 
 		/* determine activated columns. */
-		mid_weight = 0;
 		for (idx = 0; idx < CHORD_SIZE; idx++) {
-			*seed_p = (uint32_t)(3 * *seed_p + buf[idx]);
-			col_idx = *seed_p % CHORD_SIZE;
+			col_idx = (of + idx) % CHORD_SIZE;
 
 			if (buf[idx] == 0) {
-				hash->bias[col_idx] = MAX(0, hash->bias[col_idx]-1);
+//				hash->bias[col_idx] = MAX(0, hash->bias[col_idx]-1);
 				continue;
 			}
 
-			weight[col_idx] |= htm_chord_digest_bit(buf[idx]);
-			if (weight[col_idx] > mid_weight)
-				mid_weight = weight[col_idx];
-
-			hash->bias[col_idx] = MIN(255, hash->bias[col_idx]+1);
-		}
-
-		/* apply */
-		mid_weight /= 2;
-		for (col_idx = 0; col_idx < CHORD_SIZE; col_idx++) {
-			if (weight[col_idx] > mid_weight) { /* integrate */
-				uint8_t h_weight = weight[col_idx];
-				hash->vec[col_idx] |= h_weight;
+			bit = select_bits(buf[idx]);
+			{
+				uint32_t ival = (uint32_t)buf[idx];
+fprintf(stderr, "DEBUG: bit(%d)@idx%d = select_bits(%-2.2x)\n", bit, idx, ival);
 			}
+			if (bit) is_bit = 1;
+			hash->vec[col_idx] |= bit;
+//			hash->bias[col_idx] = MIN(255, hash->bias[col_idx]+1);
 		}
 	}
 
-
+fprintf(stderr, "DEBUG: DIGEST HASH: %s\n", htm_chord_hex(hash));
+	return (is_bit);
 }
 
+#if 0
 /* set in_hash onto hash */
 void htm_chord_set(chord_t *hash, chord_t *in_hash)
 {
@@ -411,6 +462,7 @@ void htm_chord_set(chord_t *hash, chord_t *in_hash)
 			continue;
 		}
 
+
 		hash->vec[i] |= in_hash->vec[i];
 #if 0
 		if (hash->vec[i] != 0) {
@@ -428,7 +480,6 @@ void htm_chord_set(chord_t *hash, chord_t *in_hash)
 	}
 
 }
-
 void htm_chord_reset(chord_t *hash, chord_t *in_hash)
 {
 	int i;
@@ -453,7 +504,6 @@ void htm_chord_reset(chord_t *hash, chord_t *in_hash)
 	}
 
 }
-
 /* absorb in_hash into hash */
 void htm_chord_pool(chord_t *hash, chord_t *in_hash)
 {
@@ -464,16 +514,44 @@ void htm_chord_pool(chord_t *hash, chord_t *in_hash)
 				in_hash->vec[i] == 0xFF) /* unclear */
 			continue;
 
-		if (hash->vec[i] != 0xFF)
-			hash->vec[i] |= in_hash->vec[i]; /* OR bits */
-		else
-			hash->vec[i] = in_hash->vec[i]; /* OR bits */
+#if 0
+		/* only apply from 'active' columns. */
+		if (in_hash->weight[i] < MID_WEIGHT)
+			break;
+#endif
 
+		hash->vec[i] |= in_hash->vec[i]; /* OR bits */
+#if 0
 		htm_chord_weight_incr(hash, i);
+#endif
 	}
 
 }
+void htm_chord_feedback(chord_t *hash, chord_t *in_hash)
+{
+  int i;
+  
+  for (i = 0; i < CHORD_SIZE; i++) {
+    if (in_hash->vec[i] == 0) {
+      htm_chord_weight_decr(hash, i);
+    } else {
+      htm_chord_weight_incr(hash, i);
+    }
+  }
+
+}
+#endif
+
+static void *_memxor(void *dest, const void *src, size_t n)
+{
+  char const *s = (const char *)src;
+  char *d = (char *)dest;
 
+  for (; n > 0; n--)
+    *d++ ^= *s++;
+
+  return dest;
+}
 void htm_chord_xor(chord_t *hash, chord_t *in_hash)
 {
 	int i;
@@ -481,12 +559,137 @@ void htm_chord_xor(chord_t *hash, chord_t *in_hash)
 	if (!in_hash)
 		return;
 
+	_memxor(hash->vec, in_hash->vec, CHORD_SIZE);
+}
+
+void htm_chord_reduce(chord_t *hash, double deg)
+{
+	uint8_t val;
+	int i;
+
+	deg = MAX(0.0, deg);
+	deg = MIN(1.0, deg);
+	val = (uint8_t)((double)256 * deg);
+
 	for (i = 0; i < CHORD_SIZE; i++) {
-		if (hash->vec[i] == 0)
-			continue;
+		if (hash->vec[i] & val)
+			hash->vec[i] &= ~val;
+	}
+
+}
+
+#if 0
+#define MAX_INSET_CORD 10240
+uint64_t htm_chord_inset(uint64_t seed, double x, double y, double z)
+{
+	chord_t hash;
+	double ar[4];
+
+	ar[0] = (x / MAX_INSET_CORD);
+	ar[1] = (y / MAX_INSET_CORD);
+	ar[2] = (z / MAX_INSET_CORD);
+	ar[3] = 0;
+
+	memset(&hash, 0, sizeof(hash));
+	htm_chord_split_set(&hash, 4, ar, MIN_CHORD_SPLIT_SIZE);
+	return (htm_chord_compact(&hash));
+}
+#endif
+
+void htm_chord_split_get(chord_t *hash, int nr, double *val_p, double max_val)
+{
+	uint64_t val;
+	uint32_t seed;
+	uint8_t buf[CHORD_SIZE];
+	int span;
+	int idx;
+	int of;
+	int i;
+
+	span = CHORD_SIZE / MAX(4, nr);
+	max_val = max_val / span;
+
+	idx = 0;
+	seed = 1;
+	for (of = 0; of < CHORD_SIZE; of += span) {
+		val = 1;
 
-		hash->vec[i] &= ~in_hash->vec[i];
+		for (i = 0; i < span; i++) {
+			buf[i] = select_bits(hash->vec[(of + i)]);
+		}
+		for (i = (span-1); i >= 0; i--) {
+			val = val << 8;
+			val += buf[i];
+			val += hash->vec[(of+i)];
+		}
+		val_p[idx++] = (double)val / max_val;
+
+		if (idx >= nr)
+			break;
 	}
 
 }
 
+void htm_chord_split_set(chord_t *hash, int nr, double *val_p, double max_val)
+{
+	uint64_t val;
+	int bit_idx;
+	int span;
+	int idx;
+	int tot;
+	int of;
+	int i;
+
+	span = CHORD_SIZE / MAX(4, nr);
+	max_val = max_val / span;
+
+	idx = 0;
+	for (of = 0; of < CHORD_SIZE; of += span) {
+		val = (uint64_t)(val_p[idx++] * max_val) - 1;
+
+		for (i = 0; i < span; i++) {
+			bit_idx = ((of+i) % CHORD_SIZE);
+			hash->vec[bit_idx] = select_bits((val & 0xFF));
+			val = val >> 8;
+		}
+
+#if 0
+		tot = 0; 
+		for (i = (span-1); i >= 0; i--) {
+			bit_idx = ((of+i) % CHORD_SIZE);
+			if (hash->vec[bit_idx])
+				tot++;
+			if (tot >= 4) hash->vec[bit_idx] = 0;
+		}
+		if (idx >= nr)
+			break;
+#endif
+
+	}
+
+}
+
+void htm_chord_rgba(chord_t *hash, uint8_t *rgba)
+{
+  double clr[4];
+
+  htm_chord_split_get(hash, 4, clr, MIN_CHORD_SPLIT_SIZE);
+
+  rgba[0] = MIN(255, (256.0 * clr[0]));
+  rgba[1] = MIN(255, (256.0 * clr[1]));
+  rgba[2] = MIN(255, (256.0 * clr[2]));
+  rgba[3] = MIN(255, (256.0 * clr[3]));
+
+}
+
+void htm_chord_rgba_set(chord_t *hash, uint8_t *rgba)
+{
+  double clr[4];
+
+  clr[0] = (double)rgba[0] / 256.0;
+  clr[1] = (double)rgba[1] / 256.0;
+  clr[2] = (double)rgba[2] / 256.0;
+  clr[3] = (double)rgba[3] / 256.0;
+  htm_chord_split_set(hash, 4, clr, MIN_CHORD_SPLIT_SIZE);
+}
+
